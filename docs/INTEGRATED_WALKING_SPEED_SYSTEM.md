# 보행속도 통합 계산 시스템

## 📋 개요

Tmap API의 기본 보행 시간을 기준값(1.0)으로 하여, 사용자 속도, 경사도, 날씨의 영향을 모두 반영한 정확한 보행 시간을 계산합니다.

## 🎯 최종 계산 공식

```
최종 보행 시간 = Tmap 기준 시간 × 사용자 속도 계수 × 경사도 계수 × 날씨 계수
```

## 📁 파일 구조

### 백엔드

1. **`Factors_Affecting_Walking_Speed.py`** (새 파일) ⭐
   - **역할**: 모든 보정 계수 통합 관리
   - **클래스**: `WalkingSpeedIntegrator`
   - **기능**:
     - 사용자 속도 계수 계산
     - 경사도 계수 계산 (Tobler's Function)
     - 날씨 계수 계산 (WeatherSpeedModel)
     - 통합 시간 계산

2. **`weather_helpers.py`** (기존)
   - **역할**: 날씨 기반 속도 계수 계산
   - **모델**: `WeatherSpeedModel`
   - **입력**: 기온, 강수형태, 강수량, 적설량
   - **출력**: 날씨 계수 (0.70 ~ 1.10)

3. **`elevation_helpers.py`** (수정)
   - **역할**: Google Elevation API 호출 및 경사도 계산
   - **모델**: Tobler's Hiking Function
   - **처리**: 통합 모듈 호출하여 최종 시간 계산

4. **`routers/routes.py`** (수정)
   - **엔드포인트**: `/api/routes/analyze-slope`
   - **파라미터**:
     - `itinerary`: Tmap 경로 데이터
     - `user_speed_mps`: 사용자 평균 속도 (m/s)
     - `weather_data`: 날씨 데이터
     - `api_key`: Google Elevation API 키

### 프론트엔드

1. **`services/elevationService.ts`** (수정)
   - 백엔드 API 호출
   - 모든 파라미터 전달

2. **`components/ApiTestComponent.tsx`** (수정)
   - Health Connect에서 사용자 속도 가져오기
   - KMA API에서 날씨 데이터 가져오기
   - 통합 계산 결과 표시

3. **`types/api.ts`** (수정)
   - 타입 정의 업데이트
   - 통합 계수 정보 포함

## 🔢 각 계수 설명

### 1. 사용자 속도 계수 (Health Connect)

```python
계수 = 기준 속도 (1.4 m/s) / 사용자 속도
```

**예시:**
- 사용자가 1.4 m/s → 계수 = 1.0 (기준)
- 사용자가 2.0 m/s → 계수 = 0.7 (30% 빠름, 시간 단축)
- 사용자가 1.0 m/s → 계수 = 1.4 (40% 느림, 시간 증가)

**범위:** 0.5 ~ 2.0

### 2. 경사도 계수 (Tobler's Function)

```python
속도(km/h) = 6 * exp(-3.5 * |경사도 + 0.05|)
계수 = 기준 속도 / 현재 속도
```

**예시:**
- 평지 (0%) → 속도 5.0 km/h, 계수 = 1.0
- 완만한 내리막 (-5%) → 속도 6.0 km/h, 계수 = 0.84 (16% 빠름)
- 완만한 오르막 (5%) → 속도 4.2 km/h, 계수 = 1.20 (20% 느림)
- 가파른 오르막 (15%) → 속도 2.5 km/h, 계수 = 2.0 (100% 느림)

### 3. 날씨 계수 (WeatherSpeedModel)

```python
계수 = 1 / weather_coeff
weather_coeff = 보폭 계수 × 보행수 계수
```

**영향 요인:**
- 기온: 10°C 부근이 최적 (시그모이드 + 가우시안)
- 강우: 비가 올수록 속도 감소 (지수 함수)
- 적설: 눈이 쌓일수록 속도 대폭 감소
- 특수 상황: 어는 비, 습설 추가 보정

**예시:**
- 맑음 18°C → 계수 ≈ 1.0
- 비 5mm/h → 계수 ≈ 1.15 (15% 느림)
- 눈 2cm/h → 계수 ≈ 1.40 (40% 느림)

**범위:** 0.70 ~ 1.10 (클램프 적용)

## 🔄 처리 흐름

```
1. [프론트엔드] 사용자가 경로 검색
   ↓
2. [프론트엔드] Tmap API 호출 → 경로 데이터 획득
   ↓
3. [프론트엔드] Health Connect → 사용자 평균 속도 (Case 1)
   ↓
4. [프론트엔드] KMA API → 현재 날씨 데이터
   ↓
5. [프론트엔드] 백엔드 API 호출
   - itinerary (Tmap 경로)
   - user_speed_mps (1.5 m/s 예시)
   - weather_data (18°C, PTY=0)
   ↓
6. [백엔드] elevation_helpers.py
   - Google Elevation API → 고도 데이터
   - 경사도 계산
   ↓
7. [백엔드] Factors_Affecting_Walking_Speed.py
   - 사용자 속도 계수 계산: 1.4/1.5 = 0.933
   - 경사도 계수 계산: Tobler(평균 3%) = 1.15
   - 날씨 계수 계산: 맑음 18°C = 1.0
   - 최종 계수: 0.933 × 1.15 × 1.0 = 1.073
   ↓
8. [백엔드] 최종 시간 계산
   - Tmap 기준: 600초 (10분)
   - 보정 시간: 600 × 1.073 = 644초 (10분 44초)
   - 시간 차이: +44초
   ↓
9. [프론트엔드] 결과 표시
   - "보정 시간: +1분"
   - "계수: 사용자(0.933) × 경사도(1.15) × 날씨(1.0) = 1.073"
```

## 📊 실제 사용 예시

### 케이스 1: 빠른 사용자, 오르막, 맑음

```python
# 입력
Tmap 기준 시간: 600초
사용자 속도: 2.0 m/s (빠름)
평균 경사도: 5% (오르막)
날씨: 맑음 18°C

# 계산
사용자 계수: 1.4 / 2.0 = 0.700 (30% 빠름)
경사도 계수: 1.200 (20% 느림)
날씨 계수: 1.000 (영향 없음)
최종 계수: 0.700 × 1.200 × 1.000 = 0.840

# 결과
최종 시간: 600 × 0.840 = 504초 (8분 24초)
시간 차이: -96초 (-1분 36초)
```

**해석:** 사용자가 빠르지만 오르막이라 일부 상쇄됨. 전체적으로 16% 빠름.

### 케이스 2: 평균 사용자, 평지, 비

```python
# 입력
Tmap 기준 시간: 600초
사용자 속도: 1.4 m/s (평균)
평균 경사도: 0% (평지)
날씨: 비 5mm/h, 10°C

# 계산
사용자 계수: 1.4 / 1.4 = 1.000
경사도 계수: 1.000
날씨 계수: 1.150 (15% 느림)
최종 계수: 1.000 × 1.000 × 1.150 = 1.150

# 결과
최종 시간: 600 × 1.150 = 690초 (11분 30초)
시간 차이: +90초 (+1분 30초)
```

**해석:** 비 때문에 15% 느려짐.

### 케이스 3: 느린 사용자, 내리막, 눈

```python
# 입력
Tmap 기준 시간: 600초
사용자 속도: 1.0 m/s (느림)
평균 경사도: -5% (내리막)
날씨: 눈 1cm/h, 0°C

# 계산
사용자 계수: 1.4 / 1.0 = 1.400 (40% 느림)
경사도 계수: 0.840 (16% 빠름)
날씨 계수: 1.250 (25% 느림)
최종 계수: 1.400 × 0.840 × 1.250 = 1.470

# 결과
최종 시간: 600 × 1.470 = 882초 (14분 42초)
시간 차이: +282초 (+4분 42초)
```

**해석:** 내리막의 이점이 사용자의 느린 속도와 눈 때문에 상쇄되어 전체적으로 47% 느림.

## 🎨 UI 표시

```
✅ 경사도 분석 완료! (보정 시간: +5분)
🚶 사용자 보행 속도: 1.50 km/h (Case 1)
🌤️ 날씨: 18°C (코드: 0)
📊 계수: 사용자(0.933) × 경사도(1.150) × 날씨(1.000) = 1.073
```

## 🔧 테스트 방법

### 1. 백엔드 직접 테스트

```python
from app.utils.Factors_Affecting_Walking_Speed import calculate_walking_time

result = calculate_walking_time(
    tmap_base_time=600,  # 10분
    user_speed_mps=1.5,  # 사용자 속도
    slope_percent=5.0,   # 5% 오르막
    weather_data={
        'temp_c': 18,
        'pty': 0,
        'rain_mm_per_h': 0,
        'snow_cm_per_h': 0
    }
)

print(result)
# {
#   'base_time': 600,
#   'user_speed_factor': 0.933,
#   'slope_factor': 1.200,
#   'weather_factor': 1.000,
#   'final_factor': 1.120,
#   'adjusted_time': 672,
#   'time_difference': 72
# }
```

### 2. 프론트엔드에서 테스트

`ApiTestComponent`에서 "경로 검색" 버튼 클릭:
1. Tmap API 호출
2. Health Connect에서 속도 가져오기
3. KMA API에서 날씨 가져오기
4. 백엔드 API 호출
5. 결과 확인

## 📌 주요 특징

1. **모듈화**: 각 계수를 독립적으로 계산
2. **확장성**: 새로운 요인 추가 용이
3. **정확성**: 과학적 모델 기반 (Tobler's Function)
4. **안전성**: 계수 범위 제한 (극단값 방지)
5. **투명성**: 각 계수를 UI에 표시하여 사용자가 이해 가능

## ⚠️ 주의사항

1. **Health Connect 데이터 없을 시**: 사용자 계수 = 1.0 (Tmap 기준 사용)
2. **날씨 데이터 없을 시**: 날씨 계수 = 1.0 (날씨 영향 없음)
3. **경사도 데이터 없을 시**: 경사도 계수 = 1.0 (평지 가정)
4. **API 오류 시**: 기준값(1.0) 사용하여 서비스 지속

## 🚀 다음 단계

1. **실시간 업데이트**: 경로 이동 중 날씨 변화 반영
2. **학습 기능**: 사용자의 실제 이동 시간 학습하여 계수 조정
3. **구간별 상세 정보**: 각 구간의 계수를 지도에 표시
4. **통계 분석**: 사용자별, 경로별 통계 수집 및 분석
